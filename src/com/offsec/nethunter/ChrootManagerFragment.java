package com.offsec.nethunter;

import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.os.PowerManager;
import android.text.Html;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;

import com.offsec.nethunter.utils.NhPaths;
import com.offsec.nethunter.utils.ShellExecuter;

import org.json.JSONException;
import org.json.JSONObject;
import org.thoughtcrime.ssl.pinning.util.PinningHelper;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;

import javax.net.ssl.HttpsURLConnection;

import androidx.appcompat.app.AlertDialog;
import androidx.core.app.NotificationCompat;
import androidx.fragment.app.Fragment;

import static android.content.Context.POWER_SERVICE;

/**
 * Created by fattire on 3/14/15.
 * This is GPLv2'd.
 * <p/>
 * This was quickly thrown together:
 * <p/>
 * TO DO:
 * <p/>
 * * Actually verify SHA of downloaded chroot file
 * * Non-arm arch support
 * * better UI (it locks up currently when untarring/zipping file...)
 * * Add "are you sure" dialog before wiping/reinstalling
 * *  Handle situations where user opens this fragment multiple times or
 * quits during download or re-opens during download, etc.  that may
 * mean making this part of its own activity or whatever...
 * * Move strings to string resources.
 * * Clean up and make it betterer
 * * Figure why "/storage/emulated/0" -> "/storage/emulated/legacy" replacement is necessary
 * on some devices
 */

public class
ChrootManagerFragment extends Fragment {

    public static final String MIGRATE_CHROOT_TAG = "MIGRATE_CHROOT_TAG";
    public static final String DELETE_CHROOT_TAG = "DELETE_CHROOT_TAG";
    public static final String CHROOT_INSTALLED_TAG = "CHROOT_INSTALLED_TAG";
    private static final String ARG_SECTION_NUMBER = "section_number";
    private static final String TAG = "CreateChroot";
    /* put chroot info here */
    private static final String IMAGE_SERVER = "https://images.offensive-security.com/";

    private static final String FILENAME_MINIMAL = "kalifs-minimal.tar.xz";
    private static final String FILENAME_FULL = "kalifs-full.tar.xz";

    private static final String URI_MINIMAL = IMAGE_SERVER + FILENAME_MINIMAL;
    private static final String URI_FULL = IMAGE_SERVER + FILENAME_FULL;
    private static final String FILENAME_BACKUP = "kalifs-backup.tar.gz";
    private final ShellExecuter x = new ShellExecuter();
    /*  Certificate pinning
    openssl s_client -showcerts -connect images.offensive-security.com:443 </dev/null 2>/dev/null|openssl x509 -outform PEM >mycertfile.pem
    Generated by tools/pin.py
    @ https://github.com/moxie0/AndroidPinning
    */
    private final String[] pins = new String[]{"d2599df9433782d82d438bd78d1573e6b80dfce1"};
    private String SHA512_MINIMAL;
    private String SHA512_FULL;
    private String SHA512;
    private String zipFilePath;
    private String installLogFile;
    private Boolean shouldLog = false;
    // if is full or minimal
    private Boolean isFull = false;
    private TextView statusText;
    private Button installButton;
    private Button updateButton;
    private ProgressDialog pd;
    private SharedPreferences sharedpreferences;
    private AlertDialog ad;
    private NhPaths nh;

    public static ChrootManagerFragment newInstance(int sectionNumber) {
        ChrootManagerFragment fragment = new ChrootManagerFragment();
        Bundle args = new Bundle();
        args.putInt(ARG_SECTION_NUMBER, sectionNumber);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        nh = new NhPaths();
        View rootView = inflater.inflate(R.layout.createchroot, container, false);
        statusText = rootView.findViewById(R.id.statusText);
        statusText.setMovementMethod(new ScrollingMovementMethod());
        installButton = rootView.findViewById(R.id.installButton);
        installButton.setOnClickListener(v -> onButtonHit());
        installButton.setText("Checking...");
        updateButton = rootView.findViewById(R.id.upgradechrootbutton);
        updateButton.setOnClickListener(v -> addMetaPackages());
        updateButton.setVisibility(View.GONE);
        sharedpreferences = getActivity().getSharedPreferences("com.offsec.nethunter", Context.MODE_PRIVATE);

        // extracte files location

        installLogFile = nh.SD_PATH + "/nh_install_" + new SimpleDateFormat("yyyyMMdd_hhmmss'.log'", Locale.US).format(new Date());
        return rootView;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        // which chroot?
        checkforLegacyChroot();
        super.onActivityCreated(savedInstanceState);
    }

    private void checkforLegacyChroot() {
        // does old chroot directory exist?
        if (getActivity() != null) {
            final View mView = getView();

            new Thread(() -> {
                String oldchrootcheck = "if [ -d " + nh.OLD_CHROOT_PATH + " ];then echo 1; fi";  // look for old chroot
                String newchrootcheck = "if [ -d " + nh.CHROOT_PATH + " ];then echo 1; fi"; //check the dir existence
                final String _res = x.RunAsRootOutput(oldchrootcheck);
                final String _res2 = x.RunAsRootOutput(newchrootcheck);

                if (mView != null) {
                    mView.post(() -> {
                        if (_res.equals("1") && !_res2.equals("1")) {
                            // old chroot but not new one
                            AlertDialog.Builder adb = new AlertDialog.Builder(getActivity());
                            adb.setTitle(R.string.legacychroottitle)
                                    .setMessage(R.string.legacychrootmessage)
                                    .setPositiveButton(R.string.legacychrootposbutton, (dialog, which) -> {
                                        dialog.cancel();
                                        startMigrateRoot();
                                    })
                                    .setNegativeButton(R.string.legacychrootnegbutton, (dialog, which) -> dialog.cancel());
                            AlertDialog ad = adb.create();
                            ad.setCancelable(false);
                            ad.show();
                        } else {
                            checkForExistingChroot();
                        }
                    });
                }

            }).start();


        }
    }

    private void startMigrateRoot() {
        installButton.setEnabled(false);
        pd = new ProgressDialog(getActivity());
        pd.setTitle(getActivity().getString(R.string.rebootingdialogtitle));
        pd.setMessage(getActivity().getString(R.string.rebootingdialogbody));
        pd.setCancelable(false);
        pd.show();
        Log.d(TAG, " PREFERENCE SET: " + MIGRATE_CHROOT_TAG);
        SharedPreferences.Editor editor = sharedpreferences.edit();
        editor.putString(MIGRATE_CHROOT_TAG, MIGRATE_CHROOT_TAG);  // the full text so we can compare later
        editor.apply(); // don't use apply() or it may not save
        try {
            new android.os.Handler().postDelayed(
                    () -> x.RunAsRootOutput("reboot"), 4000);
        } catch (RuntimeException e) {
            Log.d(TAG, "Error: ", e);
        }
    }

    private void checkForExistingChroot() {

        // does chroot directory exist?
        if (getActivity() != null) {
            statusLog(getActivity().getString(R.string.checkingforchroot) + nh.CHROOT_PATH);
            new Thread(() -> {
                String command = "if [ -d " + nh.CHROOT_PATH + " ];then echo 1; fi"; //check the dir existence
                final String _res = x.RunAsRootOutput(command);
                installButton.post(() -> {
                    SharedPreferences.Editor editor = sharedpreferences.edit();

                    if (_res.equals("1")) {
                        statusLog(getActivity().getString(R.string.existingchrootfound));
                        installButton.setText(getActivity().getResources().getString(R.string.removekalichrootbutton));
                        installButton.setEnabled(true);
                        updateButton.setVisibility(View.VISIBLE);
                        editor.putBoolean(CHROOT_INSTALLED_TAG, true);
                        editor.apply();
                    } else {
                        // chroot not found
                        statusLog(getActivity().getString(R.string.nokalichrootfound));
                        x.RunAsRootOutput("mkdir -p " + nh.NH_SYSTEM_PATH);
                        // prevents muts 'dirty' install issue /nhsystem is nethunter property.
                        statusLog("Cleaning install directory");
                        x.RunAsRootOutput("rm -rf " + nh.NH_SYSTEM_PATH + "/*");
                        installButton.setText(getActivity().getResources().getString(R.string.installkalichrootbutton));
                        installButton.setEnabled(true);
                        updateButton.setVisibility(View.GONE);
                        editor.putBoolean(CHROOT_INSTALLED_TAG, false);
                        editor.commit();
                    }
                    // don't use apply() or it may not save
                });

            }).start();
        }
    }

    private void onButtonHit() {
        shouldLog = true;
        installButton.setEnabled(false);
        statusLog("New instalation log file: " + installLogFile);
        new Thread(() -> {
            String command = "if [ -d " + nh.CHROOT_PATH + " ];then echo 1; fi"; //check the dir existence
            final String _res = x.RunAsRootOutput(command);
            installButton.post(() -> {
                if (_res.equals("1")) {
                    // the chroot is there.
                    AlertDialog.Builder adb = new AlertDialog.Builder(getActivity());
                    adb.setTitle(getActivity().getString(R.string.reallyremovechroot));
                    adb.setMessage(getActivity().getString(R.string.nogoingback));
                    adb.setPositiveButton(getActivity().getString(R.string.rebootbutton), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            reallyWipeRoot();
                        }
                    });
                    adb.setNegativeButton(getActivity().getString(R.string.chickenoutbutton), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            installButton.setEnabled(true);
                        }
                    });
                    AlertDialog ad = adb.create();
                    ad.setCancelable(false);
                    ad.show();
                } else {
                    downloadOrSdcard();
                }
            });
        }).start();
    }

    private void downloadOrSdcard() {

        AlertDialog.Builder adb = new AlertDialog.Builder(getActivity());
        adb.setTitle("Select chroot install mode:")
                .setMessage("Download is the prefered mode. Get the latest chroot from the offsec servers.\n\nYou can place a custom\nkalifs-[minimal|full].tar.gz in /sdcard\nand skip the download.\n\nAlso, You can place a back up kalifs-backup.tar.gz in /sdcard to restore your backup chroot.")
                .setNegativeButton("Restore from SdCard", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        dialog.cancel();
                        restoreBackup(false);
                    }
                })
                .setNeutralButton("Use SdCard", (dialog, which) -> {
                    dialog.cancel();
                    fullOrMinimal(false);
                })
                .setPositiveButton("Download Latest", (dialog, which) -> {
                    dialog.cancel();
                    fullOrMinimal(true);
                });

        AlertDialog ad = adb.create();
        ad.setCancelable(true);
        ad.show();
    }

    private void fullOrMinimal(final Boolean shouldDownload) {
        AlertDialog.Builder adb = new AlertDialog.Builder(getActivity());
        adb.setTitle("Select Chroot Download:")
                .setMessage("We recommend the full chroot, so you can enjoy all the nethunter features.\n\nIf you are installing from the SdCard, choose the type of chroot you copied to the SdCard.\n\nThe minimal is for testing/development")
                .setNeutralButton("Minimal Chroot", (dialog, which) -> {
                    dialog.cancel();
                    zipFilePath = nh.SD_PATH + "/" + FILENAME_MINIMAL;
                    SHA512 = SHA512_MINIMAL;
                    if (shouldDownload) {
                        // update value if is minimal
                        isFull = false;
                        if (!startZipDownload(URI_MINIMAL)) {
                            installButton.setEnabled(true);
                        }
                    } else {
                        UnziptarTask mytask = new UnziptarTask();
                        mytask.execute();
                    }
                })
                .setPositiveButton("Full Chroot", (dialog, which) -> {
                    dialog.cancel();
                    SHA512 = SHA512_FULL;
                    zipFilePath = nh.SD_PATH + "/" + FILENAME_FULL;
                    if (shouldDownload) {
                        // update value if is full
                        isFull = true;
                        if (!startZipDownload(URI_FULL)) {
                            installButton.setEnabled(true);
                        }
                    } else {
                        UnziptarTask mytask = new UnziptarTask();
                        mytask.execute();
                    }
                });
        AlertDialog ad = adb.create();
        ad.setCancelable(false);
        ad.show();
    }

    private void restoreBackup(final Boolean shouldDownload) {
        zipFilePath = nh.SD_PATH + "/" + FILENAME_BACKUP;
        if (!shouldDownload) {
            UnziptarTask mytask = new UnziptarTask();
            mytask.execute();
            }
    }

    private void addMetaPackages() {
        //for now, we'll hardcode packages in the dialog view.  At some point we'll want to grab them automatically.

        AlertDialog.Builder adb = new AlertDialog.Builder(getActivity());
        adb.setTitle("Metapackage Install & Upgrade");
        LayoutInflater inflater = getActivity().getLayoutInflater();
        final ScrollView sv = (ScrollView) inflater.inflate(R.layout.metapackagechooser, null);
        adb.setView(sv);
        Button metapackageButton = sv.findViewById(R.id.metapackagesWeb);
        metapackageButton.setOnClickListener(v -> {
            String metapackagesURL = "http://tools.kali.org/kali-metapackages";
            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(metapackagesURL));
            startActivity(browserIntent);
        });
        adb.setPositiveButton(R.string.InstallAndUpdateButtonText, (dialog, which) -> {
            statusLog("Everything went fine, chroot is installed. Selecting metapackages.");
            StringBuilder sb = new StringBuilder();
            CheckBox cb;
            // now grab all the checkboxes in the dialog and check their status
            // thanks to "user2" for a 2-line sample of how to get the dialog's view:  http://stackoverflow.com/a/13959585/3035127
            AlertDialog d = (AlertDialog) dialog;
            LinearLayout ll = d.findViewById(R.id.metapackageLinearLayout);
            int children = ll.getChildCount();
            for (int cnt = 0; cnt < children; cnt++) {
                if (ll.getChildAt(cnt) instanceof CheckBox) {
                    cb = (CheckBox) ll.getChildAt(cnt);
                    if (cb.isChecked()) {
                        sb.append(cb.getText()).append(" ");
                    }
                }
            }

            installAndUpgrade(sb.toString());
        });
        ad = adb.create();
        ad.setCancelable(true);
        ad.show();
    }

    private void installAndUpgrade(String packages) {

        try {

            Intent intent = new Intent("com.offsec.nhterm.RUN_SCRIPT_NH");
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.putExtra("com.offsec.nhterm.iInitialCommand", nh.makeTermTitle("Updating") + "apt update && apt install " + packages + " && echo \"\nUpgrade completed.\nEnjoy. (You can close the terminal now)\n\"");
            Log.d("PACKS:", "PACKS:" + packages);
            startActivity(intent);

            if (packages.equals("")) {
                packages = "No packages selected. You can come back and install them at any moment.";
            }
            statusLog("Metapackages selected: " + packages);
        } catch (Exception e) {
            nh.showMessage(getString(R.string.toast_install_terminal));
            statusLog("Error: Terminal app not found, cant continue. Install a terminal.");
            checkForExistingChroot();
        }
    }

    private void reallyWipeRoot() {
        installButton.setEnabled(false);
        pd = new ProgressDialog(getActivity());
        pd.setTitle(getActivity().getString(R.string.rebootingdialogtitle));
        pd.setMessage(getActivity().getString(R.string.rebootingdialogbody));
        pd.setCancelable(false);
        pd.show();
        Log.d(TAG, " PREFERENCE SET: " + DELETE_CHROOT_TAG);
        SharedPreferences.Editor editor = sharedpreferences.edit();
        editor.putString(DELETE_CHROOT_TAG, DELETE_CHROOT_TAG);  // the full text so we can compare later
        editor.apply(); // don't use apply() or it may not save
        try {
            new android.os.Handler().postDelayed(
                    () -> x.RunAsRootOutput("reboot"), 4000);
        } catch (RuntimeException e) {
            Log.d(TAG, "Error: ", e);
        }
    }


    /* Checks if external storage is available for read and write */
    private boolean isExternalStorageWritable() {
        String state = Environment.getExternalStorageState();
        return Environment.MEDIA_MOUNTED.equals(state);
    }

    private void deleteFile(String filePath) {
        File checkFile = new File(filePath);
        if (!filePath.contains("kalifs-backup.tar.gz")){
            if (checkFile.exists()) {
                statusLog(filePath + " found.");
                statusLog(getActivity().getString(R.string.deletingforroom));
                if (checkFile.delete()) {
                    statusLog("File deleted.");
                    return;
                } else {
                    statusLog(getActivity().getString(R.string.problemdeletingoldfile));
                    return;
                }
            }
        }
    }


    private boolean startZipDownload(String _URI) {
        deleteFile(zipFilePath);
        statusLog(getActivity().getString(R.string.startingdownload));
        if (!isExternalStorageWritable()) {
            statusLog(getActivity().getString(R.string.unwritablestorageerror));
            return false;
        }
        final DownloadChroot downloadTask = new DownloadChroot(getActivity());
        downloadTask.execute(_URI);
        return true;
    }

    private void inflateZip() {
        if (getActivity() != null) {

            final View mView = getView();
            pd = new ProgressDialog(getActivity());
            pd.setTitle("Checking Download... ");
            pd.setMessage("Checking file integrity...");
            pd.setCancelable(false);
            pd.show();
            statusLog("Original SHA: " + SHA512.toUpperCase());
            new Thread(() -> {
                if (mView != null) {
                    final String[] checksumResponse = checkFileIntegrity(zipFilePath);
                    mView.post(() -> {
                        if (checksumResponse[0].equals("1")) {
                            // all In bg
                            pd.setTitle("Checking Download... OK");
                            pd.setMessage("Checking file integrity... MATCH.");

                            statusLog("New SHA: " + checksumResponse[1]);
                            statusLog("Checking file integrity... MATCH");
                            try {
                                new android.os.Handler().postDelayed(
                                        () -> {
                                            pd.dismiss();
                                            UnziptarTask mytask = new UnziptarTask();
                                            mytask.execute();
                                        }, 2000);
                            } catch (RuntimeException e) {
                                Log.d(TAG, "Error in start unzip: ", e);
                            }
                        } else {
                            pd.dismiss();
                            // needed to add the button.
                            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
                            builder.setTitle("Error in the file integrity check:");
                            builder.setMessage("Error: " + checksumResponse[1])
                                    .setNegativeButton("Abort installation", (dialog, id) -> {
                                        statusLog("Error: " + checksumResponse[1]);
                                        pd.dismiss();
                                        statusLog(getActivity().getString(R.string.downloadfailscheck));
                                        checkForExistingChroot();
                                    });

                            ad = builder.create();
                            ad.setCancelable(false);
                            ad.show();
                        }
                    });
                }

            }).start();


        }

    }

    private String[] checkFileIntegrity(String path) {
        MessageDigest md;
        String newSum;
        try {
            md = MessageDigest.getInstance("SHA-512");
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, "For some reason, no SHA512 found on this device.", e);
            return new String[]{"0", "For some reason, no SHA512 found on this device."};
        }
        try {
            FileChannel fc = new FileInputStream(path).getChannel();
            /* Code from @SnakeDoc: http://stackoverflow.com/questions/16050827/filechannel-bytebuffer-and-hashing-files */
            ByteBuffer bbf = ByteBuffer.allocateDirect(8192); // allocation in bytes - 1024, 2048, 4096, 8192
            int b;
            b = fc.read(bbf);

            while ((b != -1) && (b != 0)) {

                bbf.flip();
                byte[] bytes = new byte[b];
                bbf.get(bytes);
                md.update(bytes, 0, b);
                bbf.clear();
                b = fc.read(bbf);

            }

            byte[] result = md.digest();
            newSum = String.format("%0" + (result.length * 2) + "X", new BigInteger(1, result));
            fc.close();
        } catch (IOException ioe) {
            Log.e(TAG, "Can't read " + zipFilePath);
            return new String[]{"0", "Can't read " + zipFilePath};
        }
        // k, now check the sha.  Thanks to discussion regarding formatting at:
        // http://stackoverflow.com/questions/7166129/how-can-i-calculate-the-sha-256-hash-of-a-string-in-android
        Boolean sumpass = newSum.equalsIgnoreCase(SHA512);
        if (sumpass) {
            // match
            return new String[]{"1", newSum};
        }
        // no match
        return new String[]{"0", "BAD CHECKSUM: " + newSum};
    }

    private void doLog(String data, String fileName) {
        String[] appendToFile = {"echo '" + data + "' >> '" + fileName + "'"};
        x.RunAsRoot(appendToFile);
    }

    private void statusLog(final String status) {
        new Thread(new Runnable() {
            final GregorianCalendar cal = new GregorianCalendar();
            // quick & shorter formatter
            final DateFormat dateFormat = DateFormat.getDateTimeInstance();
            final String ts = dateFormat.format(cal.getTime());
            final String formatLog = ts + " - " + status;

            public void run() {
                if (shouldLog) {
                    doLog(formatLog, installLogFile);
                }
                statusText.post(() -> {
                    statusText.append(Html.fromHtml("<font color=\"#EDA04F\">" + ts + " - </font>"));
                    statusText.append(status + "\n");
                });
            }
        }).start();
    }


    /* --------------------------------------- asynctasks -------------------- */


    public class UnziptarTask extends AsyncTask<Void, String, Boolean> {

        // https://developer.android.com/training/scheduling/wakelock.html
        final PowerManager powerManager = (PowerManager) getActivity().getSystemService(POWER_SERVICE);
        final PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                "myapp:ChrootWakelockTag");

        Boolean isStarted = false;

        @Override
        protected void onPreExecute() {
            pd = new ProgressDialog(getActivity());
            pd.setTitle(getActivity().getString(R.string.installing_notice));
            pd.show();
            pd.setCancelable(false);
            pd.setCanceledOnTouchOutside(false);
            statusLog(getActivity().getString(R.string.unzippinganduntarring));
            super.onPreExecute();
        }

        @Override
        protected void onProgressUpdate(String... progressInfo) {
            super.onProgressUpdate(progressInfo);
            if (isStarted) {
                pd.setTitle(getString(R.string.extractinganddeploying));
            }
            pd.setMessage(progressInfo[0]);
            statusLog(progressInfo[0]);
            isStarted = true;
        }

        @Override
        protected Boolean doInBackground(Void... Void) {
            try {
                // Accquire CPU
                wakeLock.acquire();

                String fExists = x.RunAsRootOutput("[ -f " + zipFilePath + " ] && echo \"1\" || echo \"0\"");
                if (fExists.equals("0")) {
                    if ( zipFilePath.contains("tar.gz")) Log.d(TAG, "Error: No tar.gz found");
                    else Log.d(TAG, "Error: No tar.xz found");
                    publishProgress("Error: Missing file: " + zipFilePath + " not found.");
                    return false;
                }
                // Decompress, extract, and deploy the .tar.xz to the chroot destination in one step
                publishProgress(getActivity().getString(R.string.extract_chroot));
                Log.d(TAG, "Restoring kali chroot from " + zipFilePath + " to " + nh.NH_SYSTEM_PATH);

                if (zipFilePath.contains("tar.gz")) {
                    x.RunAsRootOutput(nh.APP_SCRIPTS_PATH + "/chroot_restore " + zipFilePath + " " + nh.NH_SYSTEM_PATH);
                } else {
                    x.RunAsRootOutput(nh.whichBusybox() + " tar -xJf '" + zipFilePath + "' -C '" + nh.NH_SYSTEM_PATH + "'");
                }
            } catch (RuntimeException e) {
                Log.d(TAG, "Error: ", e);
                publishProgress("Error: " + e.toString());
                statusLog(TAG + " >> Error: " + e.toString());
                return false;
            }
            return true;
        }

        @Override
        protected void onPostExecute(Boolean result) {
            if (result) {
                // Release CPU
                wakeLock.release();

                statusLog(getActivity().getString(R.string.unzippinguntarringdone));
                pd.setTitle("Intallation Successful.");
                pd.setMessage("Wait... loading metapackages");
                try {
                    new android.os.Handler().postDelayed(
                            () -> {
                                checkForExistingChroot();
                                x.RunAsRootOutput(nh.whichBusybox() + " mount -o remount,suid /data && chmod +s " + nh.CHROOT_PATH + "/usr/bin/sudo");
                                deleteFile(zipFilePath);
                                pd.dismiss();
                                addMetaPackages();
                            }, 3000);
                } catch (RuntimeException e) {
                    Log.d(TAG, "Error post extraction: ", e);
                    statusLog(TAG + " >> Error: " + e.toString());
                }

            } else {
                pd.dismiss();
                installButton.setEnabled(true);
            }
        }
    }

    private class DownloadChroot extends AsyncTask<String, Integer, String> {

        final ProgressDialog mProgressDialog;
        final NotificationManager mNotifyManager = (NotificationManager) getActivity().getSystemService(Context.NOTIFICATION_SERVICE);
        final NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(getActivity());
        private final Context context;
        double last_perc = 0.0;
        double humanSize = 0.0;
        double onePercent = 0.0;
        double fineProgress = 0.0;
        Boolean weHaveTheSha = false;
        private PowerManager.WakeLock mWakeLock;
        private boolean isRunning = true;

        public DownloadChroot(Context context) {
            this.context = context;
            mProgressDialog = new ProgressDialog(context);
            mProgressDialog.setCancelable(false);
            mProgressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, getResources().getString(R.string.cancel), (dialog, which) -> cancel(true));
        }

        @Override
        protected void onCancelled() {
            isRunning = false;
            // mProgressDialog.setTitle("Chroot download Aborted.");
            mBuilder.setContentTitle("Chroot download Aborted.")
                    .setContentText("Download canceled by the user.")
                    .setSmallIcon(R.drawable.ic_action_perm_device_information)
                    // Removes the progress bar
                    .setProgress(0, 0, false);
            mNotifyManager.notify(1, mBuilder.build());
            statusLog("Download canceled by the user, removing temp file...");
            deleteFile(zipFilePath);
            checkForExistingChroot();
            mNotifyManager.cancel(1);
        }

        @Override
        protected String doInBackground(String... sUrl) {
            InputStream input = null;
            OutputStream output = null;
            HttpsURLConnection connection = null;
            try {
                URL url = new URL(sUrl[0]);
                connection = PinningHelper.getPinnedHttpsURLConnection(context, pins, url);
                //connection = (HttpsURLConnection) url.openConnection();
                connection.connect();

                if (!weHaveTheSha) {
                    // Get SHA512 sum from JSON object ONLY 1 TIME!!!!
                    String jsonstring = getJSON();
                    JSONObject jsonObject;
                    try {
                        jsonObject = new JSONObject(jsonstring);
                        SHA512_FULL = "1c981b91b188488aec143a94d79aa2e7d81fd01badea99ff9b5a4c21ed588b485f8cadcf2edcb0ff26f3c6def3ca27beb8d60f8712c3dadf8d0ed41198dcb8c7";
                        SHA512_MINIMAL = "805f5e4dccb8468f53f670346771880b011e1819bd251b6be2f3a8c2e275c87d96ca91ff8916872abfbc68e17c60886ecae0b2be0de6f7ebe7e84945c7de5ccb";
                        if (isFull) {
                            // asign the value so the integryty check works ^^
                            SHA512 = SHA512_FULL;
                            Log.d(TAG, "IS_FULL");
                            Log.d(TAG, "SHA512_FULL: " + SHA512_FULL);
                        } else {
                            SHA512 = SHA512_MINIMAL;
                            Log.d(TAG, "IS_MINIMAL");
                            Log.d(TAG, "SHA512_MINIMAL: " + SHA512_MINIMAL);
                        }
                    } catch (JSONException e) {
                        e.printStackTrace();
                        Log.e(TAG, "JSON exception");
                    }
                    weHaveTheSha = true;
                }
                if (connection.getResponseCode() != HttpsURLConnection.HTTP_OK) {
                    return "Server returned HTTP " + connection.getResponseCode()
                            + " " + connection.getResponseMessage();
                }

                int fileLength = connection.getContentLength();
                humanSize = fileLength / 1000000; // in MB
                //humanSize = fileLength / 1048576; // in MiB
                onePercent = humanSize / 100;
                // download the file
                input = connection.getInputStream();
                output = new FileOutputStream(zipFilePath);
                byte data[] = new byte[50 * 1024];
                long total = 0;
                int count;
                while ((count = input.read(data)) != -1 && isRunning) {
                    // allow canceling with back button
                    if (isCancelled()) {
                        input.close();
                        return null;
                    }
                    total += count;
                    // publishing the progress....
                    if (fileLength > 0) // only if total length is known
                        fineProgress = round(round(total * 100) / fileLength);
                    publishProgress((int) (fineProgress));
                    output.write(data, 0, count);
                }
            } catch (Exception e) {
                return e.toString();
            } finally {
                try {
                    if (output != null)
                        output.close();
                    if (input != null)
                        input.close();
                } catch (IOException ignored) {
                }
                if (connection != null)
                    connection.disconnect();
            }
            return null;
        }

        private String getJSON() {
            {
                HttpsURLConnection jsonconnection = null;
                try {
                    URL jsonurl = new URL("https://images.offensive-security.com/version.txt");
                    jsonconnection = PinningHelper.getPinnedHttpsURLConnection(getContext(), pins, jsonurl); // Add certificated pinning
                    jsonconnection.setRequestMethod("GET");
                    jsonconnection.setRequestProperty("Content-length", "0");
                    jsonconnection.setUseCaches(false);
                    jsonconnection.setAllowUserInteraction(false);
                    int status = jsonconnection.getResponseCode();
                    jsonconnection.connect();

                    switch (status) {
                        case 200:
                        case 201:
                            BufferedReader br = new BufferedReader(new InputStreamReader(jsonconnection.getInputStream()));
                            StringBuilder sb = new StringBuilder();
                            String line;
                            while ((line = br.readLine()) != null) {
                                sb.append(line).append("\n");
                            }
                            br.close();
                            return sb.toString();
                    }

                } catch (IOException ex) {
                    Log.d(TAG, "Exception with JSON connect");
                } finally {
                    if (jsonconnection != null) {
                        try {
                            jsonconnection.disconnect();
                        } catch (Exception ex) {
                            Log.d(TAG, "Error connecting with server/file");
                        }
                    }
                }
                return null;
            }
        }

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            // instantiate it within the onCreate method
            mProgressDialog.setTitle("Starting Chroot download.");
            mProgressDialog.setIndeterminate(true);
            mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            mProgressDialog.setMax(100);
            mProgressDialog.setCancelable(false);
            mProgressDialog.setCanceledOnTouchOutside(false);
            // take CPU lock to prevent CPU from going off if the user
            // presses the power button during download
            PowerManager pm = (PowerManager) context.getSystemService(POWER_SERVICE);
            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                    getClass().getName());
            mWakeLock.acquire();
            mProgressDialog.show();
            // if the user clicks the notif, bring back the app screen to top.
            // TODO: Add something to bring back progress dialogue or add cancel button in notification bar
            Intent newIntent = new Intent(getContext(), AppNavHomeActivity.class);
            PendingIntent pIntent = PendingIntent.getActivity(getContext(), 0, newIntent, 0);
            mBuilder.setContentIntent(pIntent);
            mBuilder.setContentTitle("Downloading Chroot")
                    .setContentText("Starting download...")
                    .setSmallIcon(R.drawable.ic_action_refresh);
        }

        @Override
        protected void onProgressUpdate(Integer... progress) {
            super.onProgressUpdate(progress);
            if (fineProgress > last_perc) {
                last_perc = fineProgress;
                double ttDownloaded = round(last_perc * onePercent);
                // if we get here, length is known, now set indeterminate to false
                // Notification

                mBuilder.setProgress(100, progress[0], false)
                        .setContentTitle("Downloading Kali Chroot: " + last_perc + "%")
                        .setContentText("So far " + ttDownloaded + " MB of " + humanSize + " MB downloaded.");
                mNotifyManager.notify(1, mBuilder.build());
                // Dialog
                mProgressDialog.setIndeterminate(false);
                mProgressDialog.setProgress(progress[0]);
                mProgressDialog.setTitle("Downloading Chroot.");
            }
        }

        @Override
        protected void onPostExecute(String result) {
            mWakeLock.release();

            if (result != null) {
                mProgressDialog.dismiss();

                mBuilder.setContentTitle("Download error.")
                        .setContentText("Error in the Chroot download.")
                        .setSmallIcon(R.drawable.ic_action_perm_device_information)
                        .setProgress(0, 0, false);
                mNotifyManager.notify(1, mBuilder.build());
                statusLog("Error in the Chroot download, posible causes: server down or conection issues");
                AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
                builder.setTitle("Error in the Chroot download.");
                builder.setMessage("Error in the Chroot download, posible causes: server down or conection issues, here is the error: " + result)
                        .setNegativeButton("Cancel", (dialog, id) -> {
                            statusLog("Error in the download, removing temp file...");
                            deleteFile(zipFilePath);
                            checkforLegacyChroot();
                            mNotifyManager.cancel(1);
                        });

                ad = builder.create();
                ad.setCancelable(false);
                ad.show();
            } else {
                mProgressDialog.dismiss();
                statusLog("Chroot download completed: Total " + humanSize + " MB.");
                mBuilder.setContentTitle("Chroot download completed.").setContentText("Chroot download completed")
                        // Removes the progress bar
                        .setProgress(0, 0, false);
                mNotifyManager.notify(1, mBuilder.build());
                inflateZip();
                mNotifyManager.cancel(1);
            }
        }

        double round(double value) {
            BigDecimal bd = new BigDecimal(value).setScale(1, RoundingMode.HALF_EVEN);
            value = bd.doubleValue();
            return value;
        }
    }
}
